import { NextResponse } from 'next/server'

// Google Vision API Integration for Enhanced Brand Detection
class GoogleVisionAnalyzer {
  constructor() {
    this.apiKey = process.env.GOOGLE_CLOUD_VISION_API_KEY;
    this.endpoint = 'https://vision.googleapis.com/v1/images:annotate';
  }

  async analyzeImage(base64Image) {
    if (!this.apiKey) {
      console.log('‚ö†Ô∏è Google Vision API key not found, using Claude-only analysis');
      return null;
    }

    try {
      console.log('üîç Google Vision API analyzing image...');
      
      const response = await fetch(`${this.endpoint}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          requests: [
            {
              image: {
                content: base64Image
              },
              features: [
                { type: 'WEB_DETECTION', maxResults: 10 },
                { type: 'TEXT_DETECTION', maxResults: 10 },
                { type: 'LOGO_DETECTION', maxResults: 10 },
                { type: 'LABEL_DETECTION', maxResults: 10 }
              ]
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`Google Vision API error: ${response.status}`);
      }

      const data = await response.json();
      return this.processVisionResults(data);

    } catch (error) {
      console.error('‚ùå Google Vision analysis failed:', error);
      return null;
    }
  }

  processVisionResults(data) {
    const result = {
      brands: [],
      texts: [],
      labels: [],
      webEntities: [],
      confidence: 'low',
      detectedInfo: {
        brands: [],
        sizes: [],
        materials: [],
        careInstructions: []
      }
    };

    if (!data || !data.responses || !data.responses[0]) {
      console.log('‚ö†Ô∏è No valid response from Google Vision API');
      return result;
    }

    const response = data.responses[0];

    try {
      // Extract web entities (great for brand detection)
      if (response.webDetection && response.webDetection.webEntities && Array.isArray(response.webDetection.webEntities)) {
        result.webEntities = response.webDetection.webEntities
          .filter(entity => entity && entity.description && entity.score && entity.score > 0.5)
          .map(entity => ({
            description: entity.description,
            score: entity.score
          }));

        // Look for fashion brands
        const fashionBrands = this.extractFashionBrands(result.webEntities);
        if (Array.isArray(fashionBrands)) {
          result.brands.push(...fashionBrands);
        }
      }

      // Extract text from labels/tags
      if (response.textAnnotations && Array.isArray(response.textAnnotations)) {
        result.texts = response.textAnnotations
          .map(text => text && text.description ? text.description : '')
          .filter(text => text && text.length > 1);
        
        // Extract additional brand info and sizes from text
        const textInfo = this.extractInfoFromText(result.texts);
        if (textInfo && Array.isArray(textInfo.brands)) {
          result.brands.push(...textInfo.brands);
        }
        if (textInfo) {
          result.detectedInfo = {
            brands: textInfo.brands || [],
            sizes: textInfo.sizes || [],
            materials: textInfo.materials || [],
            careInstructions: textInfo.careInstructions || []
          };
        }
      }

      // Extract logo detection
      if (response.logoAnnotations && Array.isArray(response.logoAnnotations)) {
        const logoBrands = response.logoAnnotations
          .filter(logo => logo && logo.description && logo.score)
          .map(logo => ({
            brand: logo.description,
            confidence: logo.score,
            source: 'logo_detection'
          }));
        if (Array.isArray(logoBrands)) {
          result.brands.push(...logoBrands);
        }
      }

      // Extract general labels
      if (response.labelAnnotations && Array.isArray(response.labelAnnotations)) {
        result.labels = response.labelAnnotations
          .filter(label => label && label.description && label.score && label.score > 0.6)
          .map(label => ({
            description: label.description,
            score: label.score
          }));
      }

      // Set overall confidence
      result.confidence = this.calculateConfidence(result);
      
      const brandCount = Array.isArray(result.brands) ? result.brands.length : 0;
      const textCount = Array.isArray(result.texts) ? result.texts.length : 0;
      console.log(`‚úÖ Google Vision detected: ${brandCount} brands, ${textCount} text elements`);
      
    } catch (processError) {
      console.error('‚ùå Error processing Vision results:', processError);
    }

    return result;
  }

  extractFashionBrands(webEntities) {
    if (!Array.isArray(webEntities)) {
      return [];
    }

    const knownBrands = [
      'nike', 'adidas', 'zara', 'h&m', 'uniqlo', 'gap', 'levis', 'tommy hilfiger',
      'calvin klein', 'ralph lauren', 'hugo boss', 'armani', 'gucci', 'prada',
      'versace', 'balenciaga', 'off-white', 'supreme', 'stone island', 'cp company',
      'north face', 'patagonia', 'carhartt', 'dickies', 'vans', 'converse',
      'dr martens', 'timberland', 'ugg', 'ted baker', 'cos', 'arket',
      'weekday', 'monki', 'asos', 'topshop', 'topman', 'primark', 'next',
      'marks & spencer', 'john lewis', 'selfridges', 'harrods', 'liberty',
      'new look', 'river island', 'boohoo', 'missguided', 'pretty little thing'
    ];

    return webEntities
      .filter(entity => {
        if (!entity || !entity.description) return false;
        const desc = entity.description.toLowerCase();
        return knownBrands.some(brand => 
          desc.includes(brand) || 
          brand.includes(desc) || 
          this.fuzzyMatch(desc, brand)
        );
      })
      .map(entity => ({
        brand: entity.description,
        confidence: entity.score || 0.5,
        source: 'web_detection'
      }));
  }

  extractInfoFromText(texts) {
    const info = {
      brands: [],
      sizes: [],
      materials: [],
      careInstructions: []
    };

    if (!Array.isArray(texts) || texts.length === 0) {
      return info;
    }

    try {
      const allText = texts.join(' ').toUpperCase();

      // Extract brand names from text
      const brandPatterns = [
        /\b(NIKE|ADIDAS|ZARA|H&M|UNIQLO|GAP|LEVI'S|LEVIS)\b/gi,
        /\b(TOMMY HILFIGER|CALVIN KLEIN|RALPH LAUREN|HUGO BOSS)\b/gi,
        /\b(NORTH FACE|PATAGONIA|CARHARTT|DICKIES|STONE ISLAND)\b/gi,
        /\b(TED BAKER|COS|ARKET|WEEKDAY|MONKI|ASOS|NEXT)\b/gi
      ];

      brandPatterns.forEach(pattern => {
        try {
          const matches = allText.match(pattern);
          if (matches && Array.isArray(matches)) {
            matches.forEach(match => {
              if (match) {
                info.brands.push({
                  brand: this.formatBrandName(match),
                  confidence: 0.85,
                  source: 'text_detection'
                });
              }
            });
          }
        } catch (patternError) {
          console.error('Pattern matching error:', patternError);
        }
      });

      // Extract size information
      const sizePatterns = [
        /\b(XS|S|M|L|XL|XXL|XXXL)\b/gi,
        /\bUK\s*(\d{1,2})\b/gi,
        /\bEU\s*(\d{2,3})\b/gi,
        /\bUS\s*(\d{1,2})\b/gi,
        /\b(W\d{2}|L\d{2})\b/gi,
        /\bSIZE\s*[:\-]?\s*([XS|S|M|L|XL|\d]+)/gi
      ];

      sizePatterns.forEach(pattern => {
        try {
          const matches = allText.match(pattern);
          if (matches && Array.isArray(matches)) {
            info.sizes.push(...matches.filter(match => match));
          }
        } catch (patternError) {
          console.error('Size pattern error:', patternError);
        }
      });

      // Extract material information
      const materialPatterns = [
        /(\d+%?\s*(?:COTTON|POLYESTER|WOOL|SILK|LINEN|DENIM|LEATHER|SUEDE|CASHMERE))/gi,
        /\b(100%|COTTON|POLYESTER|WOOL|SILK|LINEN|DENIM|LEATHER|SUEDE|CASHMERE)\b/gi
      ];

      materialPatterns.forEach(pattern => {
        try {
          const matches = allText.match(pattern);
          if (matches && Array.isArray(matches)) {
            info.materials.push(...matches.filter(match => match));
          }
        } catch (patternError) {
          console.error('Material pattern error:', patternError);
        }
      });

    } catch (extractError) {
      console.error('Text extraction error:', extractError);
    }

    return info;
  }

  formatBrandName(brand) {
    if (!brand || typeof brand !== 'string') return 'Unknown';

    const brandMap = {
      'LEVI\'S': 'Levi\'s',
      'LEVIS': 'Levi\'s',
      'H&M': 'H&M',
      'TOMMY HILFIGER': 'Tommy Hilfiger',
      'CALVIN KLEIN': 'Calvin Klein',
      'RALPH LAUREN': 'Ralph Lauren',
      'HUGO BOSS': 'Hugo Boss',
      'NORTH FACE': 'The North Face',
      'STONE ISLAND': 'Stone Island',
      'TED BAKER': 'Ted Baker'
    };

    return brandMap[brand.toUpperCase()] || this.toTitleCase(brand);
  }

  toTitleCase(str) {
    if (!str || typeof str !== 'string') return '';
    return str.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  fuzzyMatch(str1, str2) {
    if (!str1 || !str2 || typeof str1 !== 'string' || typeof str2 !== 'string') {
      return false;
    }

    // Simple fuzzy matching for brand names
    const s1 = str1.toLowerCase().replace(/[^a-z0-9]/g, '');
    const s2 = str2.toLowerCase().replace(/[^a-z0-9]/g, '');
    
    if (s1.length < 3 || s2.length < 3) return false;
    
    return s1.includes(s2) || s2.includes(s1) || 
           this.levenshteinDistance(s1, s2) <= Math.min(s1.length, s2.length) * 0.3;
  }

  levenshteinDistance(str1, str2) {
    if (!str1 || !str2) return 999;
    
    const matrix = [];
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    return matrix[str2.length][str1.length];
  }

  calculateConfidence(result) {
    let score = 0;
    
    if (result.brands && Array.isArray(result.brands) && result.brands.length > 0) score += 0.4;
    if (result.texts && Array.isArray(result.texts) && result.texts.length > 3) score += 0.3;
    if (result.labels && Array.isArray(result.labels) && result.labels.length > 3) score += 0.2;
    if (result.webEntities && Array.isArray(result.webEntities) && result.webEntities.length > 0) score += 0.1;

    if (score >= 0.7) return 'high';
    if (score >= 0.4) return 'medium';
    return 'low';
  }

  // Static method to get best brand
  static getBestBrand(brands) {
    if (!brands || !Array.isArray(brands) || brands.length === 0) return null;

    // Sort by confidence and prefer logo detection
    const sorted = brands.sort((a, b) => {
      if (!a || !b) return 0;
      if (a.source === 'logo_detection' && b.source !== 'logo_detection') return -1;
      if (b.source === 'logo_detection' && a.source !== 'logo_detection') return 1;
      return (b.confidence || 0) - (a.confidence || 0);
    });

    return sorted[0] || null;
  }
}

// Enhanced Claude Analysis with Vision Integration
class EnhancedClaudeAnalyzer {
  constructor() {
    this.ukKeywords = {
      premium: ['preloved', 'vintage', 'designer', 'luxury', 'authentic', 'genuine'],
      sustainability: ['eco-friendly', 'sustainable', 'circular fashion', 'pre-owned'],
      sizing: ['UK sizing', 'true to size', 'oversized fit', 'regular fit', 'slim fit'],
      condition: ['excellent condition', 'good condition', 'like new', 'barely worn'],
      trending: ['y2k', 'cottagecore', 'dark academia', 'streetwear', 'minimalist']
    };

    this.brandTiers = {
      luxury: ['gucci', 'prada', 'versace', 'balenciaga', 'saint laurent'],
      premium: ['hugo boss', 'tommy hilfiger', 'calvin klein', 'ralph lauren', 'ted baker'],
      designer: ['cos', 'arket', 'weekday', 'monki', 'other stories'],
      mainstream: ['zara', 'h&m', 'uniqlo', 'gap', 'next', 'marks & spencer'],
      streetwear: ['supreme', 'off-white', 'stone island', 'cp company', 'palace'],
      sportswear: ['nike', 'adidas', 'north face', 'patagonia', 'under armour']
    };
  }

  async analyzeWithEnhancedVision(images, visionResults, manualOverrides = {}) {
    try {
      console.log('ü§ñ Starting enhanced Claude + Vision analysis...');

      const visionContext = this.prepareVisionContext(visionResults);
      
      // FIXED: Added proper authentication headers
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': process.env.ANTHROPIC_API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-5-sonnet-20241022',
          max_tokens: 2000,
          messages: [{
            role: 'user',
            content: [
              {
                type: 'text',
                text: this.buildEnhancedPrompt(visionContext, manualOverrides, images)
              },
              ...images.map(img => ({
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: 'image/jpeg',
                  data: img.split(',')[1]
                }
              }))
            ]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Claude API error: ${response.status}`);
      }

      const data = await response.json();
      const analysis = this.parseClaudeResponse(data.content[0].text);
      
      return this.mergeWithVisionResults(analysis, visionResults, manualOverrides);

    } catch (error) {
      console.error('‚ùå Enhanced Claude analysis failed:', error);
      throw error;
    }
  }

  prepareVisionContext(visionResults) {
    if (!visionResults || !Array.isArray(visionResults) || visionResults.length === 0) {
      return 'No Google Vision data available.';
    }

    let context = 'Google Vision API detected information:\n\n';
    
    visionResults.forEach((result, index) => {
      if (!result) return;

      if (result.brands && Array.isArray(result.brands) && result.brands.length > 0) {
        const topBrand = GoogleVisionAnalyzer.getBestBrand(result.brands);
        if (topBrand && topBrand.brand) {
          const confidence = Math.round((topBrand.confidence || 0) * 100);
          context += `Image ${index + 1} - Top detected brand: ${topBrand.brand} (confidence: ${confidence}%)\n`;
          
          if (result.brands.length > 1) {
            const otherBrands = result.brands.slice(1, 3).map(b => b && b.brand ? b.brand : 'Unknown').filter(b => b !== 'Unknown');
            if (otherBrands.length > 0) {
              context += `Image ${index + 1} - Other brands: ${otherBrands.join(', ')}\n`;
            }
          }
        }
      }
      
      if (result.detectedInfo) {
        if (result.detectedInfo.sizes && Array.isArray(result.detectedInfo.sizes) && result.detectedInfo.sizes.length > 0) {
          const sizes = result.detectedInfo.sizes.slice(0, 3).filter(s => s);
          if (sizes.length > 0) {
            context += `Image ${index + 1} - Detected sizes: ${sizes.join(', ')}\n`;
          }
        }
        if (result.detectedInfo.materials && Array.isArray(result.detectedInfo.materials) && result.detectedInfo.materials.length > 0) {
          const materials = result.detectedInfo.materials.slice(0, 2).filter(m => m);
          if (materials.length > 0) {
            context += `Image ${index + 1} - Detected materials: ${materials.join(', ')}\n`;
          }
        }
      }

      if (result.labels && Array.isArray(result.labels) && result.labels.length > 0) {
        const fashionLabels = result.labels.filter(l => {
          if (!l || !l.description) return false;
          const desc = l.description.toLowerCase();
          return desc.includes('clothing') ||
                 desc.includes('apparel') ||
                 desc.includes('fashion') ||
                 desc.includes('textile');
        });
        if (fashionLabels.length > 0) {
          const labelNames = fashionLabels.map(l => l.description).filter(d => d);
          if (labelNames.length > 0) {
            context += `Image ${index + 1} - Fashion labels: ${labelNames.join(', ')}\n`;
          }
        }
      }
    });

    return context;
  }

  buildEnhancedPrompt(visionContext, manualOverrides, images) {
    const imageCount = Array.isArray(images) ? images.length : 0;
    
    return `You are a UK eBay fashion expert. Analyze these clothing/fashion images and create the perfect UK eBay title.

GOOGLE VISION API CONTEXT:
${visionContext}

CRITICAL UK MARKET REQUIREMENTS:
1. Use "PRELOVED" instead of "used" (UK buyers prefer this)
2. Always include UK sizing when possible (UK8, UK10, UK12, etc.)
3. Use proven UK keywords: vintage, authentic, designer, sustainable, cottagecore, y2k, streetwear
4. Focus on condition (excellent, like new, barely worn)
5. Include trending style keywords that UK buyers search for

MANUAL OVERRIDES:
${manualOverrides && manualOverrides.gender ? `Gender Override: ${manualOverrides.gender}` : 'No gender override'}
${manualOverrides && manualOverrides.size ? `Size Override: ${manualOverrides.size}` : 'No size override'}

BRAND DETECTION PRIORITY:
1. If Google Vision detected brands with high confidence, prioritize those
2. Cross-reference with visual analysis for verification
3. If multiple brands detected, choose the most prominent/visible one
4. If no Vision brands, rely on visual analysis

ENHANCED ANALYSIS REQUIRED:
- Brand (prioritize Vision API detections with high confidence)
- Item type (dress, top, jeans, jacket, etc.)
- Size (use Vision text detection + visual analysis, prioritize UK sizing)
- Color (be specific: navy blue, burgundy, forest green, etc.)
- Material (use Vision text detection from labels + visual analysis)
- Gender (mens/womens/unisex)
- Condition (be honest but positive)
- UK market tier (luxury/premium/mainstream/vintage)

TITLE REQUIREMENTS:
- 80 characters maximum
- Include: Brand + Type + Size + Color + Key Feature
- Use UK terminology and proven keywords
- Make it searchable and appealing to UK buyers

Respond in JSON format:
{
  "title": "Perfect UK eBay title under 80 chars",
  "brand": "Detected brand name",
  "item_type": "Type of clothing",
  "size": "Size with system (UK10, EU38, M, etc.)",
  "size_confidence": "certain/likely/unclear",
  "size_system": "UK/EU/US/generic",
  "colour": "Specific color description",
  "material": "Main material composition",
  "gender": "Mens/Womens/Unisex",
  "condition": "Condition assessment",
  "uk_keywords": ["array", "of", "relevant", "UK", "keywords"],
  "market_tier": "luxury/premium/designer/mainstream/streetwear/vintage",
  "estimated_uk_value": "¬£XX-XX price range",
  "sustainability_score": "high/medium/low based on brand/materials",
  "market_appeal": "High/Medium/Low for UK market",
  "description": "2-3 sentence description for listing",
  "confidence": "High/Medium/Low overall confidence",
  "vision_integration": "how Google Vision data was used",
  "processing_info": {
    "images_processed": ${imageCount},
    "vision_confidence": "confidence in vision detection",
    "market_optimization": "enabled"
  }
}

DO NOT respond with anything other than valid JSON.`;
  }

  parseClaudeResponse(responseText) {
    try {
      let cleanedResponse = responseText.trim();
      cleanedResponse = cleanedResponse.replace(/```json\s*|\s*```/g, '');
      return JSON.parse(cleanedResponse);
    } catch (error) {
      console.error('‚ùå Failed to parse Claude response:', error);
      throw new Error('Failed to parse Claude analysis results');
    }
  }

  mergeWithVisionResults(claudeAnalysis, visionResults, manualOverrides) {
    // Apply manual overrides
    if (manualOverrides && manualOverrides.gender) {
      claudeAnalysis.gender = manualOverrides.gender;
    }
    if (manualOverrides && manualOverrides.size) {
      claudeAnalysis.size = manualOverrides.size;
      claudeAnalysis.size_confidence = 'manual_override';
    }

    // Enhance with Vision results
    if (visionResults && Array.isArray(visionResults) && visionResults.length > 0) {
      const bestVisionResult = visionResults.find(r => r && r.confidence === 'high') || visionResults.find(r => r) || null;
      
      if (bestVisionResult) {
        const visionBrand = GoogleVisionAnalyzer.getBestBrand(bestVisionResult.brands || []);
        if (visionBrand && visionBrand.confidence && visionBrand.confidence > 0.8) {
          if (!claudeAnalysis.brand || claudeAnalysis.brand === 'Unknown') {
            claudeAnalysis.brand = visionBrand.brand;
            claudeAnalysis.vision_integration = `Used Google Vision brand: ${visionBrand.brand} (${Math.round(visionBrand.confidence * 100)}% confidence)`;
          } else {
            claudeAnalysis.vision_integration = `Verified brand with Google Vision: ${visionBrand.brand}`;
          }
        }

        // Add Vision detected information
        if (bestVisionResult.detectedInfo) {
          claudeAnalysis.vision_detected_info = {
            sizes: bestVisionResult.detectedInfo.sizes && Array.isArray(bestVisionResult.detectedInfo.sizes) ? 
                   bestVisionResult.detectedInfo.sizes.slice(0, 5) : [],
            materials: bestVisionResult.detectedInfo.materials && Array.isArray(bestVisionResult.detectedInfo.materials) ? 
                      bestVisionResult.detectedInfo.materials.slice(0, 3) : [],
            texts: bestVisionResult.texts && Array.isArray(bestVisionResult.texts) ? 
                   bestVisionResult.texts.slice(0, 10) : []
          };
        }
      }
    }

    // Enhance UK keywords
    claudeAnalysis.uk_keywords = this.enhanceUKKeywords(claudeAnalysis);
    claudeAnalysis.market_tier = this.calculateMarketTier(claudeAnalysis.brand);
    
    return claudeAnalysis;
  }

  enhanceUKKeywords(analysis) {
    const keywords = [...(analysis.uk_keywords && Array.isArray(analysis.uk_keywords) ? analysis.uk_keywords : [])];
    
    // Add brand-specific keywords
    if (analysis.brand && typeof analysis.brand === 'string') {
      const brand = analysis.brand.toLowerCase();
      if (this.brandTiers.luxury.includes(brand)) {
        keywords.push('luxury', 'designer', 'investment piece');
      } else if (this.brandTiers.vintage || (analysis.condition && analysis.condition.includes('vintage'))) {
        keywords.push('vintage', 'retro', 'classic');
      }
    }

    // Always add sustainability keywords for UK market
    keywords.push('preloved', 'sustainable fashion');

    return [...new Set(keywords)];
  }

  calculateMarketTier(brand) {
    if (!brand || typeof brand !== 'string') return 'unknown';
    
    const brandLower = brand.toLowerCase();
    
    for (const [tier, brands] of Object.entries(this.brandTiers)) {
      if (Array.isArray(brands) && brands.includes(brandLower)) {
        return tier;
      }
    }
    
    return 'mainstream';
  }
}

// Main API Route Handler
export async function POST(request) {
  try {
    const { images, manualOverrides = {} } = await request.json();
    
    if (!images || !Array.isArray(images) || images.length === 0) {
      return NextResponse.json({ error: 'No images provided' }, { status: 400 });
    }

    console.log(`üöÄ Starting Phase 1 enhanced analysis: Google Vision + Claude for ${images.length} images`);

    const googleVision = new GoogleVisionAnalyzer();
    const claudeAnalyzer = new EnhancedClaudeAnalyzer();

    // Step 1: Analyze with Google Vision API (parallel processing)
    console.log('üîç Step 1: Google Vision API analysis...');
    const visionPromises = images.map(async (image, index) => {
      try {
        if (!image || typeof image !== 'string') {
          console.log(`‚ö†Ô∏è Invalid image ${index + 1}`);
          return null;
        }
        
        const base64Data = image.split(',')[1];
        if (!base64Data) {
          console.log(`‚ö†Ô∏è No base64 data for image ${index + 1}`);
          return null;
        }

        const result = await googleVision.analyzeImage(base64Data);
        if (result) {
          const brandCount = Array.isArray(result.brands) ? result.brands.length : 0;
          const textCount = Array.isArray(result.texts) ? result.texts.length : 0;
          console.log(`‚úÖ Vision analysis ${index + 1}: ${brandCount} brands, ${textCount} texts detected`);
        }
        return result;
      } catch (error) {
        console.error(`‚ùå Vision analysis ${index + 1} failed:`, error);
        return null;
      }
    });

    const visionResults = await Promise.all(visionPromises);
    
    // Step 2: Enhanced Claude analysis with Vision context
    console.log('ü§ñ Step 2: Enhanced Claude analysis with Vision integration...');
    const finalAnalysis = await claudeAnalyzer.analyzeWithEnhancedVision(
      images, 
      visionResults, 
      manualOverrides
    );

    // Log results
    console.log('‚úÖ Phase 1 enhanced analysis complete!');
    console.log('üè∑Ô∏è Final brand:', finalAnalysis.brand || 'Unknown');
    console.log('üìè Final size:', finalAnalysis.size || 'Not specified');
    console.log('üîç Vision integration:', finalAnalysis.vision_integration || 'No Vision data used');
    console.log('üá¨üáß UK Keywords:', Array.isArray(finalAnalysis.uk_keywords) ? finalAnalysis.uk_keywords.join(', ') : 'None');

    return NextResponse.json(finalAnalysis);

  } catch (error) {
    console.error('‚ùå Phase 1 enhanced analysis failed:', error);
    return NextResponse.json(
      { error: `Analysis failed: ${error.message}` },
      { status: 500 }
    );
  }
}